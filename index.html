
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <title>3D Cube</title>
</head>
	
	<body style="background-color:black;">


		<canvas id="cnv" width="800" height="800" style="background-color:black; border:1px solid #ffffff;  position: absolute;
  z-index: 15;
  top: 50%;
  left: 50%;
  margin: -400px 0 0 -400px;">"></canvas>
    	<script>

    		var speed = 50;


    		var Vertex = function(x, y, z) {
    			this.x = parseFloat(x);
    			this.y = parseFloat(y);
    			this.z = parseFloat(z);
    		};

    		var Vertex2D = function(x, y) {
    			this.x = parseFloat(x);
    			this.y = parseFloat(y);
    		};

    		var Cube = function(center, side) {
    		    // Generate the vertices
    		    var d = side / 2;

    		    this.vertices = [
    		    new Vertex(center.x - d, center.y - d, center.z + d),
    		    new Vertex(center.x - d, center.y - d, center.z - d),
    		    new Vertex(center.x + d, center.y - d, center.z - d),
    		    new Vertex(center.x + d, center.y - d, center.z + d),
    		    new Vertex(center.x + d, center.y + d, center.z + d),
    		    new Vertex(center.x + d, center.y + d, center.z - d),
    		    new Vertex(center.x - d, center.y + d, center.z - d),
    		    new Vertex(center.x - d, center.y + d, center.z + d)
    		    ];
    		};

    		function project(M) {
    		    // Distance between the camera and the plane
    		    var d = 500;
    		    var r = d / M.y;

    		    return new Vertex2D(r * M.x, r * M.z);
    		}

    		function render(objects, ctx, dx, dy) {
    		    // Clear the previous frame
    		    ctx.clearRect(0, 0, 2*dx, 2*dy);


    		    // For each object
    		    for (var i = 0, n_obj = objects.length; i < n_obj; ++i) {
    		        // For each face
    		        for (var j = 0, n_faces = objects[i].vertices.length; j < n_faces; ++j) {

    		        	if(objects[i].vertices[j].y > 90)
    		        	{
    		        	var P = project(objects[i].vertices[j]);
    		            ctx.beginPath();
    		            ctx.arc(P.x + dx,-P.y + dy,1,0,2*Math.PI);
    		            ctx.stroke();
    		            ctx.fillStyle = "green";
    		            ctx.fill();
    		        }
    		    }
    		}
    		}

    		(function() {
    		    // Fix the canvas width and height
    		    var canvas = document.getElementById('cnv');
    		    canvas.width = canvas.offsetWidth;
    		    canvas.height = canvas.offsetHeight;
    		    var dx = canvas.width / 2;
    		    var dy = canvas.height / 2;

    		    // Objects style
    		    var ctx = canvas.getContext('2d');
    		    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
    		    ctx.fillStyle = 'rgba(0, 150, 255, 0.3)';

    		    // Create the cube
    		    var cube_center = new Vertex(0, 500, 0);
    		    var cube = new Cube(cube_center, dy);
    		    var objects = [];

    		    function CubeMaker()
    		    {
    		    	for(var x = -10; x <= 10; x++)
    		    	{
    		    		for(var y = -10; y <= 10; y++)
    		    		{
    		    			objects.push(new Cube(new Vertex(x * 50, 500, y * 50), 50));
    		    		}
    		    	}

    		    	for(var x = -10; x <= 10; x++)
    		    	{
    		    		for(var y = -10; y <= 10; y++)
    		    		{
    		    			objects.push(new Cube(new Vertex(600, x * 50, y * 50), 50));
    		    		}
    		    	}

    		    	for(var x = -10; x <= 10; x++)
    		    	{
    		    		for(var y = -10; y <= 10; y++)
    		    		{
    		    			objects.push(new Cube(new Vertex(-600, x * 50, y * 50), 50));
    		    		}
    		    	}


    		    	for(var x = -10; x <= 10; x++)
    		    	{
    		    		for(var y = -10; y <= 10; y++)
    		    		{
    		    			//objects.push(new Cube(new Vertex(y * 50, x * 50, 600), 50));
    		    		}
    		    	}

    		    	for(var x = -10; x <= 10; x++)
    		    	{
    		    		for(var y = -10; y <= 10; y++)
    		    		{
    		    			//objects.push(new Cube(new Vertex(x * 50, 700, y * 50), 50));
    		    		}
    		    	}

    		    	for(var x = -10; x <= 10; x++)
    		    	{
    		    		for(var y = -10; y <= 10; y++)
    		    		{
    		    			//objects.push(new Cube(new Vertex(x * 50, 800, y * 50), 50));
    		    		}
    		    	}

    		    	for(var x = -10; x <= 10; x++)
    		    	{
    		    		for(var y = -10; y <= 10; y++)
    		    		{
    		    			//objects.push(new Cube(new Vertex(x * 50, 900, y * 50), 5000));
    		    		}
    		    	}

    		    	for(var x = -10; x <= 10; x++)
    		    	{
    		    		for(var y = -10; y <= 10; y++)
    		    		{
    		    			//objects.push(new Cube(new Vertex(x * 50, 1000, y * 5000), 50));
    		    		}
    		    	}

    		    	for(var x = -10; x <= 10; x++)
    		    	{
    		    		for(var y = -10; y <= 10; y++)
    		    		{
    		    			//objects.push(new Cube(new Vertex(x * 50, 2000, y * 50), 50));
    		    		}
    		    	}

    		    	for(var x = -10; x <= 10; x++)
    		    	{
    		    		for(var y = -10; y <= 10; y++)
    		    		{
    		    			//objects.push(new Cube(new Vertex(x * 5, 500, y * 5), 5));
    		    		}
    		    	}

    		    	for(var x = -10; x <= 10; x++)
    		    	{
    		    		for(var y = -10; y <= 10; y++)
    		    		{
    		    			//objects.push(new Cube(new Vertex(x * 5, 600, y * 5), 5));
    		    		}
    		    	}

    		    	//objects.push(new Cube(new Vertex(100, 500, 100), 100));

    		    	//objects.push(new Cube(new Vertex(200, 500, 100), 100));

    		    	//objects.push(new Cube(new Vertex(400, 500, 100), 100));

    		    	//objects.push(new Cube(new Vertex(100, 500, 400), 100));

    		    	//objects.push(new Cube(new Vertex(200, 500, 400), 100));

    		    	//objects.push(new Cube(new Vertex(300, 10000, 400), 1000000));
    		    }
    		    
    		    CubeMaker();
    		    // First render
    		    render(objects, ctx, dx, dy);

    		    // Events
    		    var mousedown = false;
    		    var mx = 0;
    		    var my = 0;

    		    canvas.addEventListener('mousedown', initMove);
    		    document.addEventListener('mousemove', move);
    		    document.addEventListener('mouseup', stopMove);

    		    // Rotate a vertice
    		    function rotate(M, center, theta, phi) {
    		        // Rotation matrix coefficients
    		        var ct = Math.cos(theta);
    		        var st = Math.sin(theta);
    		        var cp = Math.cos(phi);
    		        var sp = Math.sin(phi);

    		        // Rotation
    		        var x = M.x - center.x;
    		        var y = M.y - center.y;
    		        var z = M.z - center.z;

    		        M.x = ct * x - st * cp * y + st * sp * z + center.x;
    		        M.y = st * x + ct * cp * y - ct * sp * z + center.y;
    		        M.z = sp * y + cp * z + center.z;
    		    }

    		    var rotation = 0;

    		    // Rotate a vertice
    		    function rotateX(point, radians) {
    		        var y = point.y;
    		        point.y = (y * Math.cos(radians)) + (point.z * Math.sin(radians) * -1.0);
    		        point.z = (y * Math.sin(radians)) + (point.z * Math.cos(radians));
    		    }

    		    // Utility method to rotate point by Y in a 3D space
    		    function rotateY(point, radians) {
    		    	var x = point.x;
    		    	point.x = (x * Math.cos(radians)) + (point.z * Math.sin(radians) * -1.0);
    		    	point.z = (x * Math.sin(radians)) + (point.z * Math.cos(radians));
    		    }

    		    // Utility method to rotate point by Z in a 3D space
    		    function rotateZ(point, radians) {
    		    	var x = point.x;
    		    	point.x = (x * Math.cos(radians)) + (point.y * Math.sin(radians) * -1.0);
    		    	point.y = (x * Math.sin(radians)) + (point.y * Math.cos(radians));
    		    }

    		    // Initialize the movement
    		    function initMove(evt) {
    		    	clearTimeout(autorotate_timeout);
    		    	mousedown = true;
    		    	mx = evt.clientX;
    		    	my = evt.clientY;
    		    }

    		    function move(evt) {
    		    	if (mousedown) {
    		    		var theta = (evt.clientX - mx) * Math.PI / 360;
    		    		var phi = (evt.clientY - my) * Math.PI / 180;

    		    		for (var i = 0; i < objects.length; ++i)
    		    		{
    		    			for (var j = 0; j < objects[i].vertices.length; ++j)
    		    			{	

    		    				rotate(objects[i].vertices[j], cube_center, theta, phi);
    		    			}
    		    		}
    		    		mx = evt.clientX;
    		    		my = evt.clientY;

    		    		render(objects, ctx, dx, dy);
    		    	}
    		    }


    		    function setImage(){

    		    	var now = Date.now();
    		    	var delta = now-then;

    		    	update(delta/1000);


    		    	then = now;
    		    	requestAnimationFrame(setImage);
    		    }

    		    var then = 0;

    		    var w = window;
    		    requestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;

    		    var keysDown = {};
    		    addEventListener("keydown", function(e){
    		      keysDown[e.keyCode] = true;
    		      e.preventDefault();
    		    }, false);
    		    addEventListener("keyup", function(e){
    		      delete keysDown[e.keyCode];
    		      e.preventDefault();
    		    }, false);

    		    function update(modifier){

    		      	   //up
    		      	   if(87 in keysDown){
    		      	   	for (var i = 0; i < objects.length; ++i) 
    		      	   	{
    		      	   		for (var j = 0; j < objects[i].vertices.length; ++j) 
    		      	   		{
    		      	   			objects[i].vertices[j].y -= speed;
    		      	   		}
    		      	   	}
    		      	   	//cube_center.y -= speed;
    		      	   	render(objects, ctx, dx, dy);
    		      	   }

    		      	   //down
    		      	   if(83 in keysDown){
    		      	   	for (var i = 0; i < objects.length; ++i) 
    		      	   	{
    		      	   		for (var j = 0; j < objects[i].vertices.length; ++j) 
    		      	   		{
    		      	   			objects[i].vertices[j].y += speed;
    		      	   		}
    		      	   	}
    		      	   	//cube_center.y += speed;
    		      	   	render(objects, ctx, dx, dy);
    		      	   }

    		      	   //left
    		      	   if(65 in keysDown){

    		      	   	for (var i = 0; i < objects.length; ++i) 
    		      	   	{
    		      	   		for (var j = 0; j < objects[i].vertices.length; ++j) 
    		      	   		{
    		      	   			objects[i].vertices[j].x += speed;
    		      	   		}
    		      	   	}
    		      	   	//cube_center.x += speed;
    		      	   	render(objects, ctx, dx, dy);
    		      	   }
    		      	   //right
    		      	   if(68 in keysDown){ 
    		      	   	for (var i = 0; i < objects.length; ++i) 
    		      	   	{
    		      	   		for (var j = 0; j < objects[i].vertices.length; ++j) 
    		      	   		{
    		      	   			objects[i].vertices[j].x -= speed;

    		      	   			//rotate(objects[i].vertices[j], cube_center, Math.PI / 90, -Math.PI / 90);
    		      	   		}
    		      	   	}
    		      	   	//cube_center.x -= speed;
    		      	   	render(objects, ctx, dx, dy);
    		      	   } 


    		      	   if(39 in keysDown){ 
    		      	   	rotation += Math.PI/90;
    		      	   		for (var i = 0; i < objects.length; ++i)
    		      	   		{
    		      	   			for (var j = 0; j < objects[i].vertices.length; ++j)
    		      	   			{
    		      	   	 			var p = objects[i].vertices[j];
    		      	   	 			
    		      	   	 			rotateZ(p, rotation);
    		      	   	 			
    		      	   	 		}
    		      	   	 	}
    		      	   	 	

    		      	   	 	render(objects, ctx, dx, dy);
    		      	   	 	rotation = 0;
    		      	}

    		      	   if(37 in keysDown){ 
    		      	   	rotation -= Math.PI/90;
    		      	   		for (var i = 0; i < objects.length; ++i)
    		      	   		{
    		      	   			for (var j = 0; j < objects[i].vertices.length; ++j)
    		      	   			{
    		      	   	 			var p = objects[i].vertices[j];
    		      	   	 			
    		      	   	 			rotateZ(p, rotation);
    		      	   	 			
    		      	   	 		}
    		      	   	 	}
    		      	   	 	

    		      	   	 	render(objects, ctx, dx, dy);

    		      	   	 	rotation = 0;
    		      	}


    		      	   if(38 in keysDown){ 
    		      	   	rotation -= Math.PI/90;
    		      	   		for (var i = 0; i < objects.length; ++i)
    		      	   		{
    		      	   			for (var j = 0; j < objects[i].vertices.length; ++j)
    		      	   			{
    		      	   	 			var p = objects[i].vertices[j];
    		      	   	 			
    		      	   	 			rotateX(p, rotation);
    		      	   	 			
    		      	   	 		}
    		      	   	 	}
    		      	   	 	

    		      	   	 	render(objects, ctx, dx, dy);
    		      	   	 	rotation = 0;
    		      	}

    		      	   if(40 in keysDown){ 
    		      	   	rotation += Math.PI/90;
    		      	   		for (var i = 0; i < objects.length; ++i)
    		      	   		{
    		      	   			for (var j = 0; j < objects[i].vertices.length; ++j)
    		      	   			{
    		      	   	 			var p = objects[i].vertices[j];
    		      	   	 			
    		      	   	 			rotateX(p, rotation);
    		      	   	 			
    		      	   	 		}
    		      	   	 	}
    		      	   	 	

    		      	   	 	render(objects, ctx, dx, dy);

    		      	   	 	rotation = 0;
    		      	}

    		      }


    		      	function displaywheel(e){
    		      	    var evt=window.event || e //equalize event object
    		      	    var delta=evt.detail? evt.detail*(-120) : evt.wheelDelta //check for detail first so Opera uses that instead of wheelDelta


    		      	    if(delta == 120)
    		      	    {
    		      	    	for (var i = 0; i < objects.length; ++i) 
    		      	    	{
    		      	    		for (var j = 0; j < objects[i].vertices.length; ++j) 
    		      	    		{
    		      	    			objects[i].vertices[j].z -= speed;
    		      	    		}
    		      	    	}
    		      	    	//cube_center.z -= speed;
    		      	    	render(objects, ctx, dx, dy);
    		      	    }
    		      	    else
    		      	    {
    		      	    	{
    		      	    		for (var i = 0; i < objects.length; ++i) 
    		      	    		{
    		      	    			for (var j = 0; j < objects[i].vertices.length; ++j) 
    		      	    			{
    		      	    				objects[i].vertices[j].z += speed;
    		      	    			}
    		      	    		}
    		      	    		//cube_center.z += speed;
    		      	    		render(objects, ctx, dx, dy);
    		      	    	}
    		      	    }
    		      	}
    		      	
    		      	 
    		      	var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x
    		      	 
    		      	if (document.attachEvent) //if IE (and Opera depending on user setting)
    		      	    document.attachEvent("on"+mousewheelevt, displaywheel)
    		      	else if (document.addEventListener) //WC3 browsers
    		      	    document.addEventListener(mousewheelevt, displaywheel, false)
    		      	 


    		   function stopMove() {
    		   	mousedown = false;
    		   	autorotate_timeout = setTimeout(autorotate, 2000);
    		   }

    		   function autorotate() {
    		   	for (var i = 0; i < objects.length; ++i)
    		   	{
    		   		for (var j = 0; j < objects[i].vertices.length; ++j)
    		   		{
    		    			//rotateX(objects[i].vertices[j], cube_center, -Math.PI / 720, Math.PI / 720);

    		    			//var p = objects[i].vertices[j];
    		    			
    		    			//rotateX(p, rotation);
    		    			
    		    		}
    		    	}
    		    	//rotation += Math.PI/90;

    		    	render(objects, ctx, dx, dy);

    		    	autorotate_timeout = setTimeout(autorotate, 30);
    		    }
    		    autorotate_timeout = setTimeout(autorotate, 2000);
    		    setImage();
    		})();




    	</script>

	</body>
</html>
